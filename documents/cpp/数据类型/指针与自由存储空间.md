>我们经常会使用到变量，我们一般的使用方向就是单纯的定义一个变量名，我们在访问变量名的时候，会自动的到特定的内存内访问，就可以访问到变量所存的内容了。我们有时候会在变量名里面存一个指针，这样我们访问到的就是指针了。

### 所以我们可以分为常规变量和指针变量。
我们在访问常规变量的时候例如`int name`，访问他会直接访问到变量的值，但是我们也可以去访问这个变量所在的内存指针，我们只需要使用地址运算符&即可

```cpp
int donuts = 6;
cout << donuts << $donuts
// 以上会输出 6 ， 0x0065fd40
// 因为内存一般都是十六进制的表示手法
```
### c和cpp的区别就在于run-time和compile-time的阶段。
c更注重于compile阶段的写法，cpp更注重于run-time的决策问题。compile-time会处理好所有数据所占据的内存空间，这就以为着很有可能会造成内存的浪费以及在分配时的苦恼。run-time就更加的灵活了，可以动态的决定内存的大小。cpp所用的正是频繁的在runtime使用关键字new请求新的内存空间以及使用指针跟踪这个空间。

之前我们谈到变量，变量存储着值，我们可以查询到其的地址，
相反的我们可以让变量存储的指针，然后查询到他的值。
我们假设manly是一个指针，则他其实就是内存内的一个地址。

我们可以尝试着去使用它

```cpp
int main() {
    int updates = 6;
    int *p_updates;
    p_updates = &updates
    cout << *p_updates;
    return 0;
}
```

updates是一个值，我们可以通过&来获取他的地址。
p_updates是一个地址，我们可以通过*来获得他的值。

在我们初始化一个指针的时候，并没有给地址，相反，而是先给值，这会造成我们无法解释他所在内存的位置。这将会导致一些难以跟踪的bug。

### 我们也可以手动去赋予一个十六进制的数。
C语言允许这么做，但是cpp是不允许的，因为他到底只是一串数值，而非地址，我们需要转化为地址的数据结构`(int *) 0xB8000000`即可。
int值的地址和int值不是一个东西与概念。例如有些平台的int是2个字节，但是int地址是4个字节。所以规范好是应该的。

### 指针最主要的用处在于new分配内存的指向
前面我们提到的关于指针的使用都是片面的，我们将已经有变量名字的内存地址存到一个指针上，用处不是特别大的。

我们在运行阶段分配未命名内存以存储值，在这种情况下只能通过指针来访问内存。在C中我们使用库函数malloc()来分配，在cpp中依然可以这么做，但是cpp有着更好使用的new运算符。

下面我将申请一块int的内存
```cpp
int *p = new int;
```
上面便有了一个新的int空间，并且p指向该内存的起始位置。且上面的方法只能通过指针来进行访问。这里的p指向的是一个“数据对象”。

需要知道new分配的内存和变量声明的还是不同的，new分配的内存在堆，而变量声明的内存分配于栈。

有了分配当然也需要删除内存，就以上方为例，删除地址即可`delete p`。这样做事删除了p所在的内存空间，并将其归还内存池，int *p还是存在的。我们也不能释放声明变量的内存空间`&p`。

### 我们也可以使用new来创建动态数组

我们在使用基础数据的时候还是不要瞎掺和指针，就用基础的声明就好了。new 的用处是给复杂变量的，他需要在运行的时候获取到用户输入的信息来动态申请空间，这才是new的精髓。需要多少，什么时候需要，才能够更好的利用系统的性能。

1. 使用new创建数组
```cpp
int *psome = new int [10];
// 使用完成后应该，方括号意思是释放整个数组
delete [] psome
```
注意以上的指针是指向10个元素的第一个元素的首地址，但是编译器会自动跟踪所有内存的指向，所以我们可以一次性直接利用api删除所有数组的信息，释放整个内存空间。

2. 如何使用动态数组
我们之前已经知道了，指针其实是只指着第一个项的首地址，我们怎么去寻找其他的项呢？例如上面的例子，我们知道int占4个字节，则将指针向后移动4个字节，就是第二个元素了。当然我们有着很简便的方式去使用数组！
```cpp
psome[0] = 1;
psome[1] = 2;
...
```
对的，我们只需要地址名加上方括号进行访问和赋值即可。

### 让我们指针和数组的契合的原因在于 指针算术
我们将数字+1，则值+1，我们将指针+1，则增加的量等同于new内存空间的单位量（例如int，则实际上是地址向后+4了）。

实际上我们在执行数组访问 的时候其实都是转换了这种形式的访问

```cpp
arr[i] => *(arr + i)
```

### 字符串在使用引号的时候就已经开辟空间了
也就意味着，你将一个字符串赋给一个值，那么会自动将首个字符所在的地址付给他。

```cpp
const char *bird = "bird"
```
那么bird的值为字符的首字母，并不是字符串不是常规变量，而是char数组，需要谨记，我们在打印的时候也是按照地址顺序打印char数组的。

一般来说我么你打印字符的时候是默认打印char数组的，这就意味着我们的指针地址将不会被打印出来，而是cout跟着指针一个接一个打印字符。我们如果需要打印地址的话，应该强行转换为`(int *) p`

### 字符串如何复制？
我们之前清楚了，单纯的吧字符串用等号，只是复制地址而已，但有时候我们需要一个新的副本，这时候我们需要的是开辟新的空间，再把字符丢入。最好是使用strlen函数清楚运算字符数量，再使用new 动态申请到合适的空间来开辟。最后使用
`strcpy(food, food2) 或者 strncpy(food, food2, 20)`
当然我们使用string类就更加方便了，直接使用等号既可以完成深拷贝，不用那么麻烦。（等号重载）

### 结构struct
当然new在堆划分时具有非常优先的级别，在运行时确认内存的大小是必须的。我们的结构也同样如此，下面看看如何创建结构。

```cpp
struct food {
    int id;
    char name[20];
}

food *bbd = new food;
```

我们在使用的时候还是有点棘手的，因为我们其实是只有这个结构的首地址的。

所以cpp提供了特殊的服务，箭头成员运算符`->`，专门对付结构。
`bbd -> name`
当然还有其他的使用方法：就是`(*bbd).name`。本身首地址取值后也是结构本身（草蛋的书，能不能简单点说）










