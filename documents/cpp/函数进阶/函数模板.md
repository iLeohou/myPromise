### 函数模板
函数模板是用用的函数描述，他们使用泛型定义函数。
泛型是可用的类型(intt\double)的替换。通过将类型作为参数传入模板，使得编译器能够根据这个泛型生成对应的函数（可用同时去理解js的泛型）

定义了一个交换两个int值的函数。假设要交换两个double值，又要重新。如果需要交换两个char值，可以再次使用同样的技术。进行 这种修改将浪费宝贵的时间，且容易出错。我们使用泛型的话就能够解决这个问题，节约时间。

```cpp
template <typename any_type>// 简历一个模板，命名为any_type（一般用T）
// temp;ate <class any_type> 也是允许的
void swap(any_type &a, any_type &b) {
    any_type temp;
    temp = a;
    a = b;
    b= temp;
}
```
注意模板不创建任何函数，而是告诉编译器如何创建函数
如果传入的是int，any_type将会转变为int，以此类推。

我们使用的时候也是正常的使用，编译器将检查所使用的参数类型，并生成相应的 函数。
我们只需要在文件开始位置提供模板函数的原型，在main后提供定义即可。

```cpp
#include <iostram>
template <typename T>
void swap(T & a, T &b);
int main() {
    ...
}
void swap(T & a, T &b) {
    ...
}
```
我们还可以重载模板，是一样的，比如
```cpp
T &, T &
T [], T[]

// 使用上
template <typename T>
void swap(T & a, T & b);

template <typename T>
void swap(T & a, T & b, int n);

int main() {
    ...
}
template <typename T>
void swap(T & a, T & b) {
    ...
}

template <typename T>
void swap(T & a, T & b, int n) {
    ...
}
```

### 泛型不是万能的（显示具体化）
如果我们在定义函数的时候是定义加法，那么我们int，double都能行得通，但是万一我们穿的是结构，是对象，是数组怎么办？怎么做加法？我们或许可以重载运算符，另外一种方法就是对泛型增加限制！

我们有如下结构
```cpp
struct job {
    char name[40];
    double salary;
    int floor;
}
// cpp允许我们将一个结构赋给另外一个结构。
// 函数模板当然是能够正常运行的
// 但是当我们只想交换其中两个的时候，比如name保持不变，那么我们需要另辟蹊径。
// 我们使用`显式具体化`
// 当编译器找到与函数调用匹配的`具体化定义`时，将使用该定义，而不再寻找模板
```

### 第三代具体化标准
1. 对于给定的函数名，可以有`非模板函数`、`模板函数`和`显式具体化模板函数`以及它们的`重载版本`。 
2. `显式具体化`的原型和定义应以template<>打头，并通过名称来指出类型。 
3. `具体化`优先于`常规模板`，而`非模板函数`优先于`具体化`和`常规模板`。

所以 `非模板函数` > `显式具体化模板函数` > `模板函数`

```cpp
// 原始原型
void swap(job &, job &)
// 显示具体化模板原型
template <> void swap<job>(job &, job &);
// 常规模板原型
template <class T>
void swap(T &, T &)
```

### 实例化和具体化
函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。
编译器使用模板生成函数定义时，得到的是`模板实例`。
这种实例化方式被称为隐式实例化
编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许显式实例化。可以直接命令编译器创建特定的实例（上面的是具现化不是实例化）。
例如
`template void swap<int>(int, int)`
两者不要同时使用，会出错

### 如何使用？
对于`函数重载`、`函数模板`和`函数模板重载`,C++需要一个定义良好的策略,来决定为函数调用使用哪一个函数定义。这个过程称为重载解析。

- 第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。 
- 第2步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应 的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为double，从而与double形参匹配，而模板可以为 float生成一个实例。 
- 第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错

