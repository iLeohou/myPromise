### 内联函数
内联函数是c++为了提高运行速度的引入。常规函数和内联函数的区别在于cpp编译器图和将他们放入程序中。
编译最终产物是可执行程序——由机器码01组成。
到函数调用时，程序会立即存储该指令的内存地址，并将函数的参数复制到堆栈，调到函数起点地址，执行函数，最后调回原来的地址。这么来回跳跃就意味着我们使用函数是有一定的开销的。

内联函数，这就意味着我们会只能的将函数整合到程序中，无缝运行，不用来回跳跃。当然我们这样就意味着会丧失更多的空间（本来调用函数，是跳到特定的位置即可，现在则需要在执行的地方就存放着代码副本），我们应该去考量是否需要使用它，当我们使用很小的运行内存与运行时间的函数的时候，应该尽量去使用内联函数。

1. 在函数声明前加上inline（也就是原型）
2. 函数定义前加上inline

### 引用变量
就像char * 是指向char的指针一样
char &是指向char的引用。
下面的r和rats指向相同的值和内存单元。
可以看做和指针是相反的玩意儿。
r是结果 &r是地址。
```cpp
int rats = 3;
int & r = rats;
cout << r;
```

还是有些许不一样的，比如引用必须初始化，且不能够之后赋值改变。

引用经常被用作函数参数，c++正是因为他的存在使得其对c进行了超越。

例如我们交换两个变量的值，只有我们在时候用引用变量 | 指针变量的时候才有用，否则使用的就是副本。
```cpp
void swap(int & a, int & b) {
    int temp;
    temp = a;
    a = b;
    b = temp;
}
void swap(int * a, int * b) {
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

我们有时候还是得防止数据遭到自己不经意的修改，所以
`double refcube(const double & ra)`还是很有必要的

如果我们在接受引用为参数的函数里面传不是引用该会发生什么？
仅当我们参数为const引用的时候，我们会根据传入的数据，做出不同的反应。
```cpp
1. 传入的是正确的，则正常使用
2. 传入的是不正常的，如果是可以转换为正确的数据类型，字面量表示形式，表达式，则会在函数内部创建一个临时变量存储这些处理后的结果，然后让参数对其引用。
```

如果不是const 那就毫无意义，因为本质上你是在内部创建了变量了，无法影响外部的变量了。